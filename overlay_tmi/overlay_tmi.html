<html>
<head>
    <style type="text/css">
        body {
            font-Size: 18px;
            font-family: sans-serif;
        }
        img, span {
            vertical-align: middle;
        }
    </style>
    <script src="https://code.jquery.com/jquery-3.6.1.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
    <script src="https://github.com/tmijs/tmi.js/releases/download/v1.8.5/tmi.min.js"></script>    
    <script>
        jQuery(document).ready(async function ($) {
            
            var options = {
                channel: undefined,
                enableUserColors: true,
                enableDerivedUserColor: true,
                enableUserBadges: true,
                badgeBaseSize: 'image_url_1x',
                badgeSize: 0,
                enableActionColors: true,
                emoteBaseSize: '1.0', //1.0, 2.0,3.0
                emoteTheme: 'light',
                emoteSize: 16,
                emoteJoinEnabled: false,
                autodelete: true,
                autoscroll: true,
                debugLogTags: false
            }
            
            var node_log = $(document.body);
            var badge_sets_cache = undefined;
            var badge_sets_cache_state=0;
            var user_color_cache = {};
            
            function replaceRange(arry, start,end, val) {
                for(let d = start;d<=end; d++) {
                    arry[d] = "";
                }                  
                arry[start] = val;
            }            

            function replaceEmotes(message, emotes) { 
                // based on https://github.com/tmijs/tmi.js/issues/11
                let newMessage = message.split("");
                let emoteCount = 0;

                for(const emoteIndex in emotes) {
                    const emote = emotes[emoteIndex];
                    for(const charIndexes in emote) {
                        let emoteIndexes = emote[charIndexes];
                        if(typeof emoteIndexes == "string") {
                            emoteIndexes = emoteIndexes.split("-");                            
                            replaceRange(newMessage, parseInt(emoteIndexes[0]), parseInt(emoteIndexes[1]), '<img src="http://static-cdn.jtvnw.net/emoticons/v2/' + emoteIndex + '/default/'+options.emoteTheme+'/'+options.emoteBaseSize+'"'+(options.emoteSize>0?' height="'+options.emoteSize+'"':'')+'>');
                            emoteCount++;
                        }
                    }
                }
                
                // now lets sanitize the whole thing
                let $sanitize = $('<dummy/>');
                let tail =0; 
                for (let idx=0; idx<newMessage.length;idx++) {
                    if (newMessage[idx].startsWith('<img')) {
                        if (idx>tail) {
                            replaceRange(newMessage, tail, idx-1,$sanitize.text(newMessage.slice(tail, idx).join("")).html());
                        }
                        tail = idx+1;
                    }
                }
                replaceRange(newMessage, tail, newMessage.length-1,$sanitize.text(newMessage.slice(tail, newMessage.length).join("")).html());

                if (options.emoteJoinEnabled && emoteCount>1) {
                    return newMessage.join("").replaceAll('> <img ', '><img ');
                } else {
                    return newMessage.join("");
                }
            }
            
            function getUserColor(username) {
                let result = user_color_cache[username];
                if (result == undefined) {
                    // based on: https://stackoverflow.com/questions/3426404/create-a-hexadecimal-result-based-on-a-string-with-javascript
                    var hash = 0;
                    for (var i = 0; i < username.length; i++) {
                        hash = username.charCodeAt(i) + ((hash << 5) - hash);
                    }
                    
                    result = '#';
                    for (var i = 0; i < 3; i++) {
                        var value = (hash >> (i * 8)) & 0xFF;
                        result += ('00' + value.toString(16)).substr(-2);
                    }

                    user_color_cache[username] = result;
                }
                return result;
            }            

            async function get_badge_url(badgename, badge_detail, room_id) {

                let badge_sets_cache_local = badge_sets_cache_state;
                if (badge_sets_cache_state == 1) {
                    
                    if (room_id) {
                        try {
                            badge_sets_cache_state = 2;
                            let c_cache = await $.ajax({ url: "https://badges.twitch.tv/v1/badges/channels/"+room_id+"/display", dataType: "json", method: 'GET'});
                            c_cache = c_cache['badge_sets'];
                            $.extend(badge_sets_cache,c_cache);
                        } catch (e) {
                            console.error("error getting channel badges", e);
                        }

                        badge_sets_cache_state = 3;
                        badge_sets_cache_local = 3;

                        // fix possible wrong badges
                        window.setTimeout(() => {
                            $('img.badge').each(async function (index, elem) {
                                try {
                                    let $elem = $(elem);
                                    let parts = $elem.attr('src').split('#');
                                    if (parts.length > 1) {
                                        let url = await get_badge_url(parts[1], parts[2]);
                                        if (url) {
                                            $elem.attr('src', url);
                                        }
                                    }
                                } catch (e) {
                                    ;
                                }
                            });
                        }, 1000);
                    }

                }

                try {
                    
                    // when badge_sets_cache_state = 2, this may result in the default-badge instead of the channel one
                    // if the second message comes in before the first one is ready
                    if (badge_sets_cache_local == 3) {
                        return badge_sets_cache[badgename]['versions'][badge_detail][options.badgeBaseSize];
                    } else {
                        return badge_sets_cache[badgename]['versions'][badge_detail][options.badgeBaseSize] + '#'+badgename+'#'+badge_detail;
                    }

                } catch (e) {
                    // Means we are still loading the badge_sets, can haben if initial messages are too fast
                    if (badge_sets_cache_state == 2 || badge_sets_cache_state == 1) {
                        console.warn('can not get badge url, but badge_sets still loading', {badge_name: badgename, badge_detail: badge_detail});
                        if (badgename == 'subscriber' || badgename == 'bits') {
                            return badge_sets_cache[badgename]['versions'][1][options.badgeBaseSize] + '#'+badgename+'#'+badge_detail;
                        }
                        return undefined; //return nothing for now, no caching, try again next time                   
                    } else { 
                        console.error('can not get badge url', {badge_name: badgename, badge_detail: badge_detail});
                        // make sure we find it next time, this way we see the message only once
                        if (badge_sets_cache[badgename] == undefined) {
                            badge_sets_cache[badgename] = {versions: {}};
                        }
                        if (badge_sets_cache[badgename]['versions'][badge_detail] == undefined) {
                            badge_sets_cache[badgename]['versions'][badge_detail] = {};
                        }
                        if (badge_sets_cache[badgename]['versions'][badge_detail][options.badgeBaseSize] == undefined) {
                            badge_sets_cache[badgename]['versions'][badge_detail][options.badgeBaseSize] = '';
                        }
                    }
                }
            }

            async function appendToLog(message, tags) {
                let $e = $('<div/>');
                
                if (tags) {
                    
                    let isActionMessage = (tags['message-type'] == 'action');
                    
                    if (tags['display-name']) {                        
                        
                        if (options.enableUserBadges) {
                            if (tags.badges) {
                                let badge_str = '';
                                for (badge_name in tags.badges) {
                                    let url = await get_badge_url(badge_name, tags.badges[badge_name], tags['room-id']);
                                    if (url) {
                                        badge_str += '<img src="'+url+'" '+(options.badgeSize>0?('height="'+options.badgeSize+'"'):'')+'>';
                                    }
                                }
                                
                                if (badge_str != '') {
                                    $e.append($(badge_str));                            
                                }
                            }
                        }                        

                        let $u = $('<span/>').attr('class', 'usr').text(tags['display-name']);
                        
                        if (options.enableUserColors) {
                            if (tags.color) {
                                $u.css('color', tags.color);
                            } else if (options.enableDerivedUserColor) {
                                $u.addClass('nc').css('color', getUserColor(tags['display-name']));
                            }
                        }

                        $e.append($u).append($('<span/>').text(isActionMessage?' ':': '));
                    }

                    if (tags.emotes) {
                         
                        message = replaceEmotes(message, tags.emotes);
                    }
                    
                    if (isActionMessage) {
                        $e.addClass('action');
                        if (options.enableActionColors && options.enableUserColors) {
                            $e.css('color', $e.find('span.usr').css('color'));
                        }
                    }

                    if (tags['message-type'] == 'js-error') {
                        $e.addClass('js-error');
                    }

                    if (tags.emotes) {                         
                        $e.append($('<span/>').attr('class', 'msg').html(replaceEmotes(message, tags.emotes)));
                    } else {
                        $e.append($('<span/>').attr('class', 'msg').text(message));
                    }
                    
                } else {
                    $e.append($('<span/>').attr('class', 'msg').text(message));
                } 
                
                node_log.append($e);

                if (options.autodelete) {
                    let children = node_log.children('div:not(:last)');
                    while ((children.length > 0) && (node_log.prop('scrollHeight') > node_log.prop('clientHeight'))) {
                        children.eq(0).remove();
                        children = node_log.children('div:not(:last)')
                    }
                } else if (options.autoscroll) {
                    let ch = node_log.prop('clientHeight'), sh = node_log.prop('scrollHeight');
                    if (sh>ch) {
                        node_log.prop('scrollTop', sh);
                    }                    
                }
            }

            /* initialize everything */        
            appendToLog("Start Chat @ " + new Date().toLocaleString());        
            
            let searchParams = new URLSearchParams(window.location.search);
            for (const optionName in options) {
                let option = searchParams.get(optionName);
                if (option != undefined && option != '') {
                    if (option=="true") {
                        options[optionName] = true;
                    } else if (option=="false") {
                        options[optionName] = false;
                    } else {
                        options[optionName] = option;
                    }
                }              
            }            
            
            if (options.enableUserBadges) {
                try {
                    badge_sets_cache = await $.ajax({ url: "https://badges.twitch.tv/v1/badges/global/display", dataType: "json", method: 'GET' });
                    badge_sets_cache = badge_sets_cache['badge_sets'];
                } catch (e) {
                    badge_sets_cache = {};
                    console.error("error getting global badges", e);
                }            
                badge_sets_cache_state = 1;
            }            

            if (!options.autodelete && options.autoscroll) {
                
                $(document.body).on('wheel', (event)=>{
                    if (event.originalEvent.deltaY < 0) {
                        options.autoscroll = false;
                        $(document.body).css('border', 'solid 5px red');
                    } else {
                        let st = node_log.prop('scrollTop'), sh = node_log.prop('scrollHeight'), ch = node_log.prop('clientHeight');
                        if ((st+ch) >= (sh-20)) {
                            $(document.body).css('border', '');
                            options.autoscroll =  true;
                        }                    
                    }
                });

                $(document.body).on('touchstart', (event)=>{
                    options.autoscroll = false;
                    $(document.body).css('border', 'solid 5px orange');
                });

                $(document.body).on('touchend', (event)=>{
                    let st = node_log.prop('scrollTop'), sh = node_log.prop('scrollHeight'), ch = node_log.prop('clientHeight');
                    if ((st+ch) >= (sh-100)) {
                        $(document.body).css('border', '');
                        options.autoscroll =  true;
                    }                                              
                }); 
            }
            
            window.tmiCLient = new tmi.Client({
                channels: [ options.channel ],
                connection: {
                    reconnect: true,
                    secure: true
                }
            });

            window.tmiCLient.on("reconnect", () => {
                appendToLog("----- ~~~ -----");
            });           
              
            window.tmiCLient.on('message', (channel, tags, message, self) => {
                if (options.debugLogTags) console.log(tags);
                appendToLog(message, tags);
            });

            window.tmiCLient.connect().catch(err => {
                appendToLog('ERROR: ' + err, {"message-type": "js-error"});
            });  
        });                    
    </script>
</head>
<body class="chatlog">
</body>
</html>
