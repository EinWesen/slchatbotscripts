<html>
<head>
    <style type="text/css">
        body {
            font-Size: 18px;
            font-family: sans-serif;
        }
    </style>
    <script src="https://code.jquery.com/jquery-3.6.1.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
    <script src="https://github.com/tmijs/tmi.js/releases/download/v1.8.5/tmi.min.js"></script>    
    <script>
        jQuery(document).ready(async function ($) {
            
            var options = {
                channel: undefined,
                enableUserColors: true,
                enableUserBadges: true,
                badgeBaseSize: 'image_url_1x',
                enableActionColors: true,
                emoteBaseSize: '1.0', //1.0, 2.0,3.0
                emoteSize: 16,
                autodelete: true,
                autoscroll: true,
                debugLogTags: false
            }
            
            var node_log = $(document.body);
            var badge_sets_cache = undefined, badge_cache = {};

            function replaceEmotes(message, emotes) { 
                // based on https://github.com/tmijs/tmi.js/issues/11
                var newMessage = message.split("");

                for(var emoteIndex in emotes) {
                    var emote = emotes[emoteIndex];

                    for(var charIndexes in emote) {
                        var emoteIndexes = emote[charIndexes];

                        if(typeof emoteIndexes == "string") {
                            emoteIndexes = emoteIndexes.split("-");
                            emoteIndexes = [parseInt(emoteIndexes[0]), parseInt(emoteIndexes[1])];

                            for(var i = emoteIndexes[0]; i <= emoteIndexes[1]; ++i) {
                                newMessage[i] = "";
                            }
                            newMessage[emoteIndexes[0]] = '<img src="http://static-cdn.jtvnw.net/emoticons/v1/' + emoteIndex + '/'+options.emoteBaseSize+'"'+(options.emoteSize>0?' height="'+options.emoteSize+'"':'')+'>';
                        }
                    }
                }

                return newMessage.join("");
            }

            async function get_badge_url(badgename, badge_detail, room_id) {

                if (badge_sets_cache == undefined) {
                    
                    badge_sets_cache = {};
                    let g_cache = {}, c_cache = {}; 
                    
                    try {
                        g_cache = await $.ajax({
                                method: 'GET',
                                url: "https://badges.twitch.tv/v1/badges/global/display",
                                dataType: "jsonp"
                        });
                        g_cache = g_cache['badge_sets'];
                    } catch (e) {
                        console.error("error getting global badges", e);
                    }

                    if (room_id) {
                        try {
                            c_cache = await $.ajax({
                                    method: 'GET',
                                    url: "https://badges.twitch.tv/v1/badges/channels/"+room_id+"/display",
                                    dataType: "jsonp"
                            });
                            c_cache = c_cache['badge_sets'];
                        } catch (e) {
                            console.error("error getting global badges", e);
                        }                    
                    }
                    
                    $.extend(badge_sets_cache,g_cache, c_cache);
                }
                
                // Cache the found url, mostly so that we log errors just once
                const cacheKey = badgename+"/"+badge_detail;
                let result = badge_cache[cacheKey];
                if (result == undefined) {
                    try {
                        result = badge_sets_cache[badgename]['versions'][badge_detail][options.badgeBaseSize];
                        badge_cache[cacheKey] = result;
                    } catch (e) {
                        badge_cache[cacheKey] = '';
                        console.error('can not get badge url', badgename, badge_detail)
                    }
                }
                return result;
            }

            async function appendToLog(message, tags) {
                let $e = $('<div/>');
                
                if (tags) {
                    
                    let isActionMessage = (tags['message-type'] == 'action');
                    
                    if (tags['display-name']) {                        
                        
                        if (options.enableUserBadges) {
                            if (tags.badges) {
                                let badge_str = '';
                                for (badge_name in tags.badges) {
                                    let url = await get_badge_url(badge_name, tags.badges[badge_name], tags['room-id']);
                                    if (url) {
                                        badge_str += '<img src="'+url+'" height="'+options.emoteSize+'">';
                                    }
                                }
                                
                                if (badge_str != '') {
                                    $e.append($(badge_str));                            
                                }
                            }
                        }                        

                        let $u = $('<span/>').attr('class', 'usr').text(tags['display-name']);
                        
                        if (options.enableUserColors) {
                            if (tags.color) {
                                $u.css('color', tags.color);
                            } else {
                                $u.addClass('nc');
                            }                            
                        }

                        $e.append($u).append($('<span/>').text(isActionMessage?' ':': '));
                    }

                    if (tags.emotes) {
                         
                        message = replaceEmotes(message, tags.emotes);
                    }
                    
                    if (isActionMessage) {
                        $e.addClass('action');
                        if (options.enableActionColors && options.enableUserColors) {
                            $e.css('color', $e.find('span.usr').css('color'));
                        }
                    }

                    if (tags['message-type'] == 'js-error') {
                        $e.addClass('js-error');
                    }

                }

                // Should be safe, messages recieved from twitch seems to sanitized
                $e.append($('<span/>').attr('class', 'msg').html(message)); 
                
                node_log.append($e);

                if (options.autodelete) {
                    let children = node_log.children('div:not(:last)');
                    while ((children.length > 0) && (node_log.prop('scrollHeight') > node_log.prop('clientHeight'))) {
                        children.eq(0).remove();
                        children = node_log.children('div:not(:last)')
                    }
                } else if (options.autoscroll) {
                    let ch = node_log.prop('clientHeight'), sh = node_log.prop('scrollHeight');
                    if (sh>ch) {
                        node_log.prop('scrollTop', sh);
                    }                    
                }
            }

            appendToLog("Start Chat @ " + new Date().toLocaleString());        
            
            let searchParams = new URLSearchParams(window.location.search);
            for (const optionName in options) {
                let option = searchParams.get(optionName);
                if (option != undefined && option != '') {
                    if (option=="true") {
                        options[optionName] = true;
                    } else if (option=="false") {
                        options[optionName] = false;
                    } else {
                        options[optionName] = option;
                    }
                }              
            }            

            window.tmiCLient = new tmi.Client({
                channels: [ options.channel ],
                connection: {
                    reconnect: true,
                    secure: true
                }
            });

            window.tmiCLient.on("reconnect", () => {
                appendToLog("----- ~~~ -----");
            });           
              
            window.tmiCLient.on('message', (channel, tags, message, self) => {
                if (options.debugLogTags) console.log(tags);
                appendToLog(message, tags);
            });

            window.tmiCLient.connect().catch(err => {
                appendToLog('ERROR: ' + err, {"message-type": "js-error"});
            });  
        });                    
    </script>
</head>
<body class="chatlog">
</body>
</html>
